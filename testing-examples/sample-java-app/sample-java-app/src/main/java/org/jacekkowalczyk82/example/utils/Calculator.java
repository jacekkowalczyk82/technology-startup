package org.jacekkowalczyk82.example.utils;

//All was generated by GitHub Copilot !!!

public class Calculator {
    
    public byte add(byte a, byte b) {
        return (byte) (a + b);
    }

    public byte subtract(byte a, byte b) {
        return (byte) (a - b);
    }

    public byte multiply(byte a, byte b) {
        return (byte) (a * b);
    }

    public byte divide(byte a, byte b) {
        return (byte) (a / b);
    }

    public byte modulo(byte a, byte b) {
        return (byte) (a % b);
    }

    public byte power(byte a, byte b) {
        return (byte) Math.pow(a, b);
    }

    public byte squareRoot(byte a) {
        double result = Math.sqrt(a);
        // check if the result is NaN
        if (Double.isNaN(result)) {
            throw new ArithmeticException("Square root of value : " + a + " is not a real number");
        } else {  
            return (byte) result;
        }
    }

    public byte cubeRoot(byte a) {
        return (byte) Math.cbrt(a);
    }   

    //Silnia - factorial
    public byte factorial(byte a) {
        if (a < 0) {
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        byte result = 1;
        for (byte i = 1; i <= a; i++) {
            result *= i;
        }
        return result;
    }   

    //Silnia - factorial
    public int factorial(int a) {
        if (a < 0) {
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        int result = 1;
        for (int i = 1; i <= a; i++) {
            result *= i;
        }
        return result;
    }   

    public byte absolute(byte a) {
        return (byte) Math.abs(a);
    }

    public byte negate(byte a) {
        return (byte) -a;
    }

    public byte max(byte a, byte b) {
        return (byte) Math.max(a, b);
    }

    public byte min(byte a, byte b) {
        return (byte) Math.min(a, b);
    }

    public byte average(byte a, byte b) {
        return (byte) ((a + b) / 2);
    }

    public byte sum(byte a, byte b) {
        return (byte) (a + b);
    }

    public byte difference(byte a, byte b) {
        return (byte) (a - b);
    }

    public byte product(byte a, byte b) {
        return (byte) (a * b);
    }


    public byte quotient(byte a, byte b) {
        return (byte) (a / b);
    }

    public byte remainder(byte a, byte b) {
        return (byte) (a % b);
    }


}
